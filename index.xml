<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tearth's blog</title><link>https://tearth.dev/</link><description>Recent content on Tearth's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tearth.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>GetHashCode inside CLR: Reference types</title><link>https://tearth.dev/posts/gethashcode-inside-clr-reference-types/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/gethashcode-inside-clr-reference-types/</guid><description>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode&lt;/a>, a part of the &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netcore-3.1">Object&lt;/a> class, is one of the key method present in every class instance. Its main purpose is to calculate and return a number associated with the specified object, which will be used as hash (a very good example is &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netcore-3.1">Dictionary&lt;/a> class). This article will be split into two parts: the first one will focus on the reference types and the second one on the value types. We will focus on the internal implementation of CLR and try to figure out how exactly the hash code for reference and value types is generated.&lt;/p></description></item><item><title>Performance of Bit Manipulation Instructions (BMI)</title><link>https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/</guid><description>&lt;p>&lt;strong>Bit Manipulation Instructions&lt;/strong> (BMI) is an interesting extension for the x86-64 architecture, introduced by Intel in Haswell processors (early 2010s). Its main purpose is, as the name suggests, increasing the speed of the most common bit operations by replacing manual calculation with dedicated instructions (which means hardware support). This article will focus on the performance of three example instructions: &lt;a href="https://www.felixcloutier.com/x86/BLSI">BLSI&lt;/a> (reads the lowest bit), &lt;a href="https://www.felixcloutier.com/x86/BLSR">BLSR&lt;/a> (resets the lowest bit) and &lt;a href="https://www.felixcloutier.com/x86/TZCNT">TZCNT&lt;/a> (counts the number of trailing non-set bits).&lt;/p></description></item></channel></rss>