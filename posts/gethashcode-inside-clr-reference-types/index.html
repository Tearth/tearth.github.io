<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>GetHashCode inside CLR: Reference types - Tearth's blog</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content="Magic hidden in the internal implementation of GetHashCode in CLR - how exactly this method works for reference and value types."><meta property="og:title" content="GetHashCode inside CLR: Reference types"><meta property="og:description" content="Magic hidden in the internal implementation of GetHashCode in CLR - how exactly this method works for reference and value types."><meta property="og:type" content="article"><meta property="og:url" content="https://tearth.dev/posts/gethashcode-inside-clr-reference-types/"><meta property="og:image" content="https://tearth.dev/img/card.jpg"><meta property="article:published_time" content="2020-06-08T00:00:00+00:00"><meta property="article:modified_time" content="2020-06-08T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tearth.dev/img/card.jpg"><meta name=twitter:title content="GetHashCode inside CLR: Reference types"><meta name=twitter:description content="Magic hidden in the internal implementation of GetHashCode in CLR - how exactly this method works for reference and value types."><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/bundle.min.css><link rel="shortcut icon" href=/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-167505664-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Tearth's blog" rel=home><div class=logo__title>Tearth's blog</div><div class=logo__tagline>.NET and low-level programming</div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>GetHashCode inside CLR: Reference types</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-06-08T00:00:00Z>2020-06-08</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/.net-internals/ rel=category>.NET internals</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#theory>Theory</a></li><li><a href=#inside-clr>Inside CLR</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></div><div class="content post__content clearfix"><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode</a>, a part of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netcore-3.1">Object</a> class, is one of the key method present in every class instance. Its main purpose is to calculate and return a number associated with the specified object, which will be used as hash (a very good example is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netcore-3.1">Dictionary</a> class). This article will be split into two parts: the first one will focus on the reference types and the second one on the value types. We will focus on the internal implementation of CLR and try to figure out how exactly the hash code for reference and value types is generated.</p><h2 id=theory>Theory</h2><p>Let&rsquo;s start from the beginning: what characteristics should have a hash function to be useful for programmers. According to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">documentation of GetHashCode method</a>, we can point three the most important:</p><ul><li>If instance X is equal to the instance Y, then hash code returned from the X must be equal to the hash code returned from the Y. <strong>It doesn&rsquo;t work backward!</strong> If instance X returns hash code HX and instance Y returns hash code HY, where HX and HY are the same, then it doesn&rsquo;t mean that both instances are equal.</li><li>Hash code should be even distribution, which means that small change in one of the instance fields should produce a big change in the number generated by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode</a> method.</li><li>Hash function should be inexpensive (in terms of performance) and don&rsquo;t throw any exceptions.</li></ul><p>Every class inherits (implicit or explicit) from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netcore-3.1">Object</a> class, which guarantees that you will have a set of methods (<a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.equals?view=netcore-3.1">Equals</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gettype?view=netcore-3.1">GetType</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.tostring?view=netcore-3.1">ToString</a>) available in every instance. What&rsquo;s more, .NET provides a default implementation for all of them, which means that you can use them without overriding and making custom algorithms.</p><p>The theory shown above sounds cool, but things are going to be a little complicated. In .NET, we can distinguish two basic types which determine how an object behaves: reference and value types. Let&rsquo;s talk about reference types first.</p><h2 id=inside-clr>Inside CLR</h2><p>One of the popular myths says that hash code in reference types is directly related to its address in memory. <strong>It&rsquo;s false!</strong> Yes, it doesn&rsquo;t depend from the fields within instance due to performance and practical reasons - if you have <code>Person</code> class with Age, then changing this member won&rsquo;t change hash code unless you provide your implementation of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode</a>. It&rsquo;s really important to remember, that garbage collector not only deletes unused objects but also compacts rest of the entries reduce holes between them - which means that there is always a chance that object will change its address (C# provides a <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/fixed-statement>fixed</a> keyword which locks object&rsquo;s position in memory). In this situation, basing on this during generating hash code would be pointless.</p><p>Most of the articles don&rsquo;t explain how exactly hash code is generated, and what formula is used - we will try to find out this. First, let&rsquo;s check what is the implementation of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.gethashcode?view=netcore-3.1">RuntimeHelpers.GetHashCode</a> method (used directly by default in <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">Object.GetHashCode</a>):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-csharp data-lang=csharp><span class=na>[MethodImplAttribute(MethodImplOptions.InternalCall)]</span>
<span class=k>public</span> <span class=k>static</span> <span class=k>extern</span> <span class=kt>int</span> <span class=n>GetHashCode</span><span class=p>(</span><span class=kt>object</span> <span class=n>o</span><span class=p>);</span>
</code></pre></td></tr></table></div></div><p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute?view=netcore-3.1">MethodImplAttribute</a> attribute indicates that the implementation can be found inside CLR - to find out how hash code is generated for reference types, we will dig into <a href=https://github.com/dotnet/runtime>CLR source code</a>. First, let&rsquo;s check how the internal method is mapped into the C++ source. We can find it in <a href=https://github.com/dotnet/runtime/blob/f62e93416a1799aecc6b0947adad55a0d9870732/src/coreclr/src/vm/ecalllist.h#L885>/src/coreclr/src/vm/ecalllist.h</a> file, which can be described as the bridge between C# internal calls and C++ functions. Let&rsquo;s find our method:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>FCFuncElement</span><span class=p>(</span><span class=s>&#34;GetHashCode&#34;</span><span class=p>,</span> <span class=n>ObjectNative</span><span class=o>::</span><span class=n>GetHashCode</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>This line indicates, that the <code>GetHashCode</code> is mapped into <code>ObjectNative::GetHashCode</code> function. We can find it in <a href=https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/coreclr/src/classlibnative/bcltype/objectnative.cpp#L87>/src/coreclr/src/classlibnative/bcltype/objectnative.cpp</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=hl><span class=lnt>36
</span></span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Note that we obtain a sync block index without actually building a sync block.
</span><span class=c1>// That&#39;s because a lot of objects are hashed, without requiring support for
</span><span class=c1></span><span class=n>FCIMPL1</span><span class=p>(</span><span class=n>INT32</span><span class=p>,</span> <span class=n>ObjectNative</span><span class=o>::</span><span class=n>GetHashCode</span><span class=p>,</span> <span class=n>Object</span><span class=o>*</span> <span class=n>obj</span><span class=p>)</span> <span class=p>{</span>

    <span class=n>CONTRACTL</span>
    <span class=p>{</span>
        <span class=n>FCALL_CHECK</span><span class=p>;</span>
        <span class=n>INJECT_FAULT</span><span class=p>(</span><span class=n>FCThrow</span><span class=p>(</span><span class=n>kOutOfMemoryException</span><span class=p>););</span>
    <span class=p>}</span>
    <span class=n>CONTRACTL_END</span><span class=p>;</span>

    <span class=n>VALIDATEOBJECT</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=n>OBJECTREF</span> <span class=nf>objRef</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span>

    <span class=p>{</span>
        <span class=n>DWORD</span> <span class=n>bits</span> <span class=o>=</span> <span class=n>objRef</span><span class=o>-&gt;</span><span class=n>GetHeader</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetBits</span><span class=p>();</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>bits</span> <span class=o>&amp;</span> <span class=n>BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>bits</span> <span class=o>&amp;</span> <span class=n>BIT_SBLK_IS_HASHCODE</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=c1>// Common case: the object already has a hash code
</span><span class=c1></span>                <span class=k>return</span>  <span class=n>bits</span> <span class=o>&amp;</span> <span class=n>MASK_HASHCODE</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>else</span>
            <span class=p>{</span>
                <span class=c1>// We have a sync block index. This means if we already have a hash code,
</span><span class=c1></span>                <span class=c1>// it is in the sync block, otherwise we generate a new one and store it there
</span><span class=c1></span>                <span class=n>SyncBlock</span> <span class=o>*</span><span class=n>psb</span> <span class=o>=</span> <span class=n>objRef</span><span class=o>-&gt;</span><span class=n>PassiveGetSyncBlock</span><span class=p>();</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>psb</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
                <span class=p>{</span>
<span class=hl>                    <span class=n>DWORD</span> <span class=n>hashCode</span> <span class=o>=</span> <span class=n>psb</span><span class=o>-&gt;</span><span class=n>GetHashCode</span><span class=p>();</span>
</span>                    <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
                        <span class=k>return</span>  <span class=n>hashCode</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=n>FC_INNER_RETURN</span><span class=p>(</span><span class=n>INT32</span><span class=p>,</span> <span class=n>GetHashCodeHelper</span><span class=p>(</span><span class=n>objRef</span><span class=p>));</span>
<span class=p>}</span>
<span class=n>FCIMPLEND</span>
</code></pre></td></tr></table></div></div><p>This is quite a nice piece of code, so let&rsquo;s stop for a moment. First, we need to know that every instance in .NET contains an internal field called &ldquo;SyncBlock Index&rdquo; - this is the index of the entry in internal CLR array, which contains things required for proper work in a multithread environment. By default, &ldquo;SyncBlock Index&rdquo; is set to -1 which means that the object isn&rsquo;t used for synchronization. If we will use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor.enter?view=netcore-3.1">Monitor.Enter</a> with some object as a parameter, then a proper entry in the SyncBlock list will be created and associated.</p><p>Now, look at the code above. First, the CLR reads the header of instance and checks (<code>bits & BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX</code>) if the value of SyncBlock index targets entry in SyncBlock list or contains hashcode. The second one can be a bit misleading, but it&rsquo;s a smart optimization which allows reducing memory usage by using this field to store hash code if there is no any SyncBlock associated with an object.</p><p>The second condition (<code>bits & BIT_SBLK_IS_HASHCODE</code>) is more specific and checks if the SyncBlock index contains proper hash code. If yes, we can just return the value (because it means that something earlier generated and stored it). Otherwise, it means that there is already some SyncBlock entry created and associated with an object, so we can&rsquo;t read or store hash code here. In this case, hash code is stored inside SyncBlock entry to avoid conflict and that&rsquo;s why CLR reads entry using <code>SyncBlock *psb = objRef->PassiveGetSyncBlock();</code>. Then, hash code is read with <code>psb->GetHashCode()</code> and returned.</p><p>If the first condition (<code>bits & BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX</code>) is false, then it means that hash code doesn&rsquo;t exist for the particular object and has to be generated. This is done by <code>FC_INNER_RETURN(INT32, GetHashCodeHelper(objRef));</code> line, where we can spot the <code>GetHashCodeHelper</code> call. Let&rsquo;s see what&rsquo;s inside:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=hl><span class=lnt> 9
</span></span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>NOINLINE</span> <span class=k>static</span> <span class=n>INT32</span> <span class=nf>GetHashCodeHelper</span><span class=p>(</span><span class=n>OBJECTREF</span> <span class=n>objRef</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>DWORD</span> <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=n>FC_INNER_PROLOG</span><span class=p>(</span><span class=n>ObjectNative</span><span class=o>::</span><span class=n>GetHashCode</span><span class=p>);</span>

    <span class=n>HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1</span><span class=p>(</span><span class=n>Frame</span><span class=o>::</span><span class=n>FRAME_ATTR_EXACT_DEPTH</span><span class=o>|</span><span class=n>Frame</span><span class=o>::</span><span class=n>FRAME_ATTR_CAPTURE_DEPTH_2</span><span class=p>,</span> <span class=n>objRef</span><span class=p>);</span>

<span class=hl>    <span class=n>idx</span> <span class=o>=</span> <span class=n>objRef</span><span class=o>-&gt;</span><span class=n>GetHashCodeEx</span><span class=p>();</span>
</span>
    <span class=n>HELPER_METHOD_FRAME_END</span><span class=p>();</span>
    <span class=n>FC_INNER_EPILOG</span><span class=p>();</span>
    <span class=k>return</span> <span class=n>idx</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This function is in fact just a <code>objRef->GetHashCodeEx()</code> call - rest of the code is used by internal CLR mechanisms. We can found it in <a href=https://github.com/dotnet/runtime/blob/ab49e0f9dcd56958148827c6b47428b56187b5f8/src/coreclr/src/vm/object.cpp#L49>/src/vm/object.cpp</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=hl><span class=lnt>38
</span></span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=hl><span class=lnt>70
</span></span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>INT32</span> <span class=n>Object</span><span class=o>::</span><span class=n>GetHashCodeEx</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>CONTRACTL</span>
    <span class=p>{</span>
        <span class=n>MODE_COOPERATIVE</span><span class=p>;</span>
        <span class=n>THROWS</span><span class=p>;</span>
        <span class=n>GC_NOTRIGGER</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>CONTRACTL_END</span>

    <span class=c1>// This loop exists because we&#39;re inspecting the header dword of the object
</span><span class=c1></span>    <span class=c1>// and it may change under us because of races with other threads.
</span><span class=c1></span>    <span class=c1>// On top of that, it may have the spin lock bit set, in which case we&#39;re
</span><span class=c1></span>    <span class=c1>// not supposed to change it.
</span><span class=c1></span>    <span class=c1>// In all of these case, we need to retry the operation.
</span><span class=c1></span>    <span class=n>DWORD</span> <span class=n>iter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>DWORD</span> <span class=n>dwSwitchCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>DWORD</span> <span class=n>bits</span> <span class=o>=</span> <span class=n>GetHeader</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetBits</span><span class=p>();</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>bits</span> <span class=o>&amp;</span> <span class=n>BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>bits</span> <span class=o>&amp;</span> <span class=n>BIT_SBLK_IS_HASHCODE</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=c1>// Common case: the object already has a hash code
</span><span class=c1></span>                <span class=k>return</span>  <span class=n>bits</span> <span class=o>&amp;</span> <span class=n>MASK_HASHCODE</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>else</span>
            <span class=p>{</span>
                <span class=c1>// We have a sync block index. This means if we already have a hash code,
</span><span class=c1></span>                <span class=c1>// it is in the sync block, otherwise we generate a new one and store it there
</span><span class=c1></span>                <span class=n>SyncBlock</span> <span class=o>*</span><span class=n>psb</span> <span class=o>=</span> <span class=n>GetSyncBlock</span><span class=p>();</span>
                <span class=n>DWORD</span> <span class=n>hashCode</span> <span class=o>=</span> <span class=n>psb</span><span class=o>-&gt;</span><span class=n>GetHashCode</span><span class=p>();</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
                    <span class=k>return</span>  <span class=n>hashCode</span><span class=p>;</span>

<span class=hl>                <span class=n>hashCode</span> <span class=o>=</span> <span class=n>ComputeHashCode</span><span class=p>();</span>
</span>
                <span class=k>return</span> <span class=n>psb</span><span class=o>-&gt;</span><span class=n>SetHashCode</span><span class=p>(</span><span class=n>hashCode</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>else</span>
        <span class=p>{</span>
            <span class=c1>// If a thread is holding the thin lock we need a syncblock
</span><span class=c1></span>            <span class=k>if</span> <span class=p>((</span><span class=n>bits</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>SBLK_MASK_LOCK_THREADID</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=n>GetSyncBlock</span><span class=p>();</span>
                <span class=c1>// No need to replicate the above code dealing with sync blocks
</span><span class=c1></span>                <span class=c1>// here - in the next iteration of the loop, we&#39;ll realize
</span><span class=c1></span>                <span class=c1>// we have a syncblock, and we&#39;ll do the right thing.
</span><span class=c1></span>            <span class=p>}</span>
            <span class=k>else</span>
            <span class=p>{</span>
                <span class=c1>// We want to change the header in this case, so we have to check the BIT_SBLK_SPIN_LOCK bit first
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>bits</span> <span class=o>&amp;</span> <span class=n>BIT_SBLK_SPIN_LOCK</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=n>iter</span><span class=o>++</span><span class=p>;</span>
                    <span class=k>if</span> <span class=p>((</span><span class=n>iter</span> <span class=o>%</span> <span class=mi>1024</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>g_SystemInfo</span><span class=p>.</span><span class=n>dwNumberOfProcessors</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span>
                    <span class=p>{</span>
                        <span class=n>YieldProcessorNormalized</span><span class=p>();</span> <span class=c1>// indicate to the processor that we are spinning
</span><span class=c1></span>                    <span class=p>}</span>
                    <span class=k>else</span>
                    <span class=p>{</span>
                        <span class=n>__SwitchToThread</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>++</span><span class=n>dwSwitchCount</span><span class=p>);</span>
                    <span class=p>}</span>
                    <span class=k>continue</span><span class=p>;</span>
                <span class=p>}</span>

<span class=hl>                <span class=n>DWORD</span> <span class=n>hashCode</span> <span class=o>=</span> <span class=n>ComputeHashCode</span><span class=p>();</span>
</span>
                <span class=n>DWORD</span> <span class=n>newBits</span> <span class=o>=</span> <span class=n>bits</span> <span class=o>|</span> <span class=n>BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX</span> <span class=o>|</span> <span class=n>BIT_SBLK_IS_HASHCODE</span> <span class=o>|</span> <span class=n>hashCode</span><span class=p>;</span>

                <span class=k>if</span> <span class=p>(</span><span class=n>GetHeader</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>SetBits</span><span class=p>(</span><span class=n>newBits</span><span class=p>,</span> <span class=n>bits</span><span class=p>)</span> <span class=o>==</span> <span class=n>bits</span><span class=p>)</span>
                    <span class=k>return</span> <span class=n>hashCode</span><span class=p>;</span>
                <span class=c1>// Header changed under us - let&#39;s restart this whole thing.
</span><span class=c1></span>            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>This is in fact just an extended version of the previously described <a href=https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/coreclr/src/classlibnative/bcltype/objectnative.cpp#L87>ObjectNative::GetHashCode</a>, with more checks to ensure thread safety. The most interesting line is <code>hashCode = ComputeHashCode();</code>, which calls the function to calculate new hash code - the part we are looking for.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=hl><span class=lnt>12
</span></span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// follow the necessary rules to get a new valid hashcode for an object
</span><span class=c1></span><span class=n>DWORD</span> <span class=n>Object</span><span class=o>::</span><span class=n>ComputeHashCode</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>DWORD</span> <span class=n>hashCode</span><span class=p>;</span>

    <span class=c1>// note that this algorithm now uses at most HASHCODE_BITS so that it will
</span><span class=c1></span>    <span class=c1>// fit into the objheader if the hashcode has to be moved back into the objheader
</span><span class=c1></span>    <span class=c1>// such as for an object that is being frozen
</span><span class=c1></span>    <span class=k>do</span>
    <span class=p>{</span>
        <span class=c1>// we use the high order bits in this case because they&#39;re more random
</span><span class=hl><span class=c1></span>        <span class=n>hashCode</span> <span class=o>=</span> <span class=n>GetThread</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetNewHashCode</span><span class=p>()</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=mi>32</span><span class=o>-</span><span class=n>HASHCODE_BITS</span><span class=p>);</span>
</span>    <span class=p>}</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>hashCode</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>   <span class=c1>// need to enforce hashCode != 0
</span><span class=c1></span>
    <span class=c1>// verify that it really fits into HASHCODE_BITS
</span><span class=c1></span>     <span class=n>_ASSERTE</span><span class=p>((</span><span class=n>hashCode</span> <span class=o>&amp;</span> <span class=p>((</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=n>HASHCODE_BITS</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=o>==</span> <span class=n>hashCode</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>hashCode</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Let&rsquo;s anaylze what does <code>hashCode = GetThread()->GetNewHashCode() >> (32-HASHCODE_BITS);</code> mean. First, we see that hash code is generated using the specified thread - which means that instance X will have different hash code depending on thread which generated it. Second, there is some misterious bit shift using <code>HASHCODE_BITS</code> constant, defined in <a href=https://github.com/Potapy4/dotnet-coreclr/blob/master/src/vm/syncblk.h#L123>/src/vm/syncblk.h</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#define HASHCODE_BITS                   26
</span></code></pre></td></tr></table></div></div><p>Authors of CLR decided that 26-bit hash code will be even distribution, which is one of the key hash code features. <code>GetNewHashCode</code> is a part of the <code>Thread</code> class and can be found in <a href=https://github.com/dotnet/runtime/blob/e1ffadd6521b29db350e701b11d78a286ecd783a/src/coreclr/src/vm/threads.h#L1738>/src/coreclr/src/vm/threads.h</a>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kr>inline</span> <span class=n>DWORD</span> <span class=nf>GetNewHashCode</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>LIMITED_METHOD_CONTRACT</span><span class=p>;</span>
    <span class=c1>// Every thread has its own generator for hash codes so that we won&#39;t get into a situation
</span><span class=c1></span>    <span class=c1>// where two threads consistently give out the same hash codes.
</span><span class=c1></span>    <span class=c1>// Choice of multiplier guarantees period of 2**32 - see Knuth Vol 2 p16 (3.2.1.2 Theorem A).
</span><span class=c1></span>    <span class=n>DWORD</span> <span class=n>multiplier</span> <span class=o>=</span> <span class=n>GetThreadId</span><span class=p>()</span><span class=o>*</span><span class=mi>4</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
    <span class=n>m_dwHashCodeSeed</span> <span class=o>=</span> <span class=n>m_dwHashCodeSeed</span><span class=o>*</span><span class=n>multiplier</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>m_dwHashCodeSeed</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>And here it is! Our final formula is quite simple - just a multiplication of thread ID with a random number (thanks to <a href=https://en.wikipedia.org/wiki/Linear_congruential_generator>linear congruential generator</a>). It&rsquo;s very effective and fast algorithm to generate new hash codes, thus ensuring even distribution. <code>m_dwHashCodeSeed</code> is initialized in <a href=https://github.com/dotnet/runtime/blob/e1ffadd6521b29db350e701b11d78a286ecd783a/src/coreclr/src/vm/threads.cpp#L1399>/src/vm/threads.cpp</a> and looks as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// Initialize this variable to a very different start value for each thread
</span><span class=c1>// Using linear congruential generator from Knuth Vol. 2, p. 102, line 24
</span><span class=c1></span><span class=n>dwHashCodeSeed</span> <span class=o>=</span> <span class=n>dwHashCodeSeed</span> <span class=o>*</span> <span class=mi>1566083941</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
<span class=n>m_dwHashCodeSeed</span> <span class=o>=</span> <span class=n>dwHashCodeSeed</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>The last unknown, <code>dwHashCodeSeed</code> is a static variable that contains the constant seed for <a href=https://en.wikipedia.org/wiki/Linear_congruential_generator>linear congruential generator</a>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>static</span>  <span class=n>DWORD</span> <span class=n>dwHashCodeSeed</span> <span class=o>=</span> <span class=mi>123456789</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><h2 id=summary>Summary</h2><p>Here, our short journey ends. We saw how a simple <a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode</a> call runs whole CLR mechanisms to generate a hash code for a reference type. Next time, we will try to do the same thing but for value types - they are much more complex and use a set of algorithms to calculate hash code, depending on the object type or fields inside a structure.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/.net/ rel=tag>.NET</a></li><li class=tags__item><a class="tags__link btn" href=/tags/.net-core/ rel=tag>.NET Core</a></li><li class=tags__item><a class="tags__link btn" href=/tags/clr/ rel=tag>CLR</a></li><li class=tags__item><a class="tags__link btn" href=/tags/gethashcode/ rel=tag>GetHashCode</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="Tearth avatar" src=https://github.com/Tearth.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About Tearth</span></div><div class=authorbox__description>IT student. I enjoy everything related to .NET and low-level programming stuff (OSDev and microcontrollers). Sometimes I create AI and games. SpaceX fan.</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/performance-of-bit-manipulation-instructions-bmi/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Performance of Bit Manipulation Instructions (BMI)</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/posts/gethashcode-inside-clr-value-types/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>GetHashCode inside CLR: Value types</p></a></div></nav><div id=comments><script>var id=3;var user_name="tearth";var repo_name="tearth.github.io";if(id)
{let url="https://github.com/"+user_name+"/"+repo_name+"/issues/"+id;let api_url="https://api.github.com/repos/"+user_name+"/"+repo_name+"/issues/"+id+"/comments";let link="<a href='"+url+"'>GitHub issue</a>";var commentsDiv=document.getElementById("comments");let xhr=new XMLHttpRequest();xhr.responseType="json";xhr.open("GET",api_url);xhr.setRequestHeader("Accept","application/vnd.github.v3.html+json");xhr.send();xhr.onload=function()
{if(xhr.status!=200)
{let errorText=document.createElement("p");errorText.innerHTML="<i>Comments for this post are not opened yet (or you have GitHub scripts disabled).</i>";commentsDiv.appendChild(errorText);}
else
{let comments=xhr.response;let mainHeader=document.createElement("h2");mainHeader.innerHTML="Comments: ".concat(comments.length);commentsDiv.appendChild(mainHeader);let issueLink=document.createElement("p");issueLink.innerHTML="<i>You can leave a comment using this <b>"+link+"</b>.</i>";commentsDiv.appendChild(issueLink);comments.forEach(function(comment)
{let commentContent=document.createElement("div");commentContent.setAttribute('class','gh-comment')
commentContent.innerHTML="".concat("<div class='gh-header'>","<img src='",comment.user.avatar_url,"' />","<div style='margin:auto 0;'>","<b><a class='gh-username' href='",comment.user.html_url,"'>",comment.user.login,"</a></b>"," commented at <em>",new Date(comment.created_at).toUTCString(),"</em>","</div>","</div>","<div class='gh-body'>",comment.body_html,"</div>");commentsDiv.appendChild(commentContent);});}};xhr.onerror=function()
{let errorText=document.createElement("p");errorText.innerHTML="<i>Looks like the GitHub API limit exceeded! Go to "+link+" directly or wait 60 minutes to reset limits.</i>";commentsDiv.appendChild(errorText);};}</script></div></div><aside class=sidebar><div class="widget-categories widget"><h4 class=widget__title>Main projects</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=https://github.com/Tearth/MicrOS><span class=project-title>MicrOS</span> - 32-bit operating system</a><div class=project-details>Language: C, Assembly. SLOC: 20000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/InElonWeTrust><span class=project-title>InElonWeTrust</span> - SpaceX Discord bot</a><div class=project-details>Language: C#. SLOC: 6000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/Cosette><span class=project-title>Cosette</span> - my best chess engine so far, 2400 Elo</a><div class=project-details>Language: C#. SLOC: 12000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/Proxima-b-2.0><span class=project-title>Proxima b 2.0</span> - chess engine for BSc Thesis</a><div class=project-details>Language: C#. SLOC: 10000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/DotNet6502><span class=project-title>DotNet6502</span> - modular MOS 6502 emulator</a><div class=project-details>Language: C#. SLOC: 6000</div></li><li class=widget__item><a class=widget__link href="https://github.com/Tearth?tab=repositories">Full list of repositories</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Nuget packages</h4><div class=widget__content><ul class=widget__list><li class=widget__item><div><a class=widget__link href=https://github.com/Tearth/Oddity><span class=project-title>Oddity</span> - unofficial SpaceX API wrapper</a></div><div><a href=https://travis-ci.org/github/Tearth/Oddity><img src="https://img.shields.io/travis/Tearth/Oddity/master?style=flat-square&logo=travis-ci&logoColor=white&cacheSeconds=3600" alt="Oddity build"></a>
<a href=https://www.nuget.org/packages/Oddity/><img src="https://img.shields.io/nuget/dt/Oddity.svg?style=flat-square&logo=nuget&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt="Oddity Nuget"></a>
<a href=https://github.com/Tearth/Oddity/stargazers><img src="https://img.shields.io/github/stars/Tearth/Oddity.svg?style=flat-square&logo=github&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt="Oddity stargazers"></a></div><div class=project-details>Language: C#. SLOC: 3000</div></li><li class=widget__item><div><a class=widget__link href=https://github.com/Tearth/.NET-Launch-Dashboard><span class=project-title>.NET Launch Dashboard</span> - rocket telemetry</a></div><div><a href=https://travis-ci.org/github/Tearth/.NET-Launch-Dashboard><img src="https://img.shields.io/travis/Tearth/.NET-Launch-Dashboard/master?style=flat-square&logo=travis-ci&logoColor=white&cacheSeconds=3600" alt=".NET-Launch-Dashboard build"></a>
<a href=https://www.nuget.org/packages/DotNetLaunchDashboard/><img src="https://img.shields.io/nuget/dt/DotNetLaunchDashboard.svg?style=flat-square&logo=nuget&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt=".NET-Launch-Dashboard Nuget"></a>
<a href=https://github.com/Tearth/.NET-Launch-Dashboard/stargazers><img src="https://img.shields.io/github/stars/Tearth/.NET-Launch-Dashboard.svg?style=flat-square&logo=github&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt=".NET-Launch-Dashboard stargazers"></a></div><div class=project-details>Language: C#. SLOC: 500</div></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/.net-internals/>.NET internals (6)</a></li><li class=widget__item><a class=widget__link href=/categories/chess-programming/>Chess programming (2)</a></li><li class=widget__item><a class=widget__link href=/categories/performance-comparisons/>Performance comparisons (4)</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/.net/ title=.NET>.NET (8)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/.net-5/ title=".NET 5">.NET 5 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/.net-core/ title=".NET Core">.NET Core (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/.net-framework/ title=".NET Framework">.NET Framework (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/assembly/ title=Assembly>Assembly (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/bmi/ title=BMI>BMI (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++ (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/chess/ title=Chess>Chess (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/clr/ title=CLR>CLR (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/gethashcode/ title=GetHashCode>GetHashCode (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/random/ title=Random>Random (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/tuples/ title=Tuples>Tuples (1)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Tearth target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Twitter rel="noopener noreferrer" href=https://twitter.com/TearthDev target=_blank><svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5.0-78.8 35.3-78.8 78.8.0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6.0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1.0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4.0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9.0 224.1-120 224.1-224.1.0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg><span>Twitter</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Lichess rel="noopener noreferrer" href=https://lichess.org/@/Tearth target=_blank><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="widget-social__link-icon icon icon-lichess" width="24" height="24" viewBox="2 3 21 21"><g id="surface1"><path style="fill-rule:evenodd;fill:#fff;fill-opacity:1;stroke-width:0" d="M22.001953 9.997559C32.497559 11.000977 38.503418 18.00293 37.998047 39.001465H15C15 30 24.997559 32.497559 22.998047 18.00293" transform="matrix(0.533333,0,0,0.533333,0,0)"/><path style="fill-rule:evenodd;fill:#fff;fill-opacity:1;stroke-width:0" d="M24.001465 18.00293C24.382324 20.910645 18.449707 25.371094 16.003418 26.99707 13.000488 28.996582 13.183594 31.340332 11.000977 31.003418 9.960938 30.058594 12.407227 27.956543 11.000977 28.000488 9.997559 28.000488 11.191406 29.230957 9.997559 30 9.001465 30 5.998535 31.003418 5.998535 26.000977 5.998535 24.001465 11.99707 13.996582 11.99707 13.996582S13.886719 12.099609 13.996582 10.50293C13.271484 9.506836 13.498535 8.503418 13.498535 7.5 14.501953 6.496582 16.501465 9.997559 16.501465 9.997559H18.500977S19.277344 8.005371 20.998535 7.001953L22.001953 9.997559" transform="matrix(0.533333,0,0,0.533333,0,0)"/><path style="fill-rule:evenodd;fill:#000;fill-opacity:1;stroke-width:0" d="M9.499512 25.50293C9.499512 25.773926 9.279785 26.000977 9.001465 26.000977 8.723145 26.000977 8.503418 25.773926 8.503418 25.50293 8.503418 25.224609 8.723145 24.997559 9.001465 24.997559 9.279785 24.997559 9.499512 25.224609 9.499512 25.50293zm0 0" transform="matrix(0.533333,0,0,0.533333,0,0)"/><path style="fill-rule:evenodd;fill:#000;fill-opacity:1;stroke-width:0" d="M14.999472 15.496922C14.996821 16.32729 14.774506 16.996929 14.499265 17.003609 14.226704 17.000284 13.999306 16.328111 14.001958 15.497742 13.998266 14.671036 14.22058 14.001397 14.499484 14.00106 14.778388 14.000723 14.995781 14.670215 14.999472 15.496922zm0 0" transform="matrix(0.461867,0.266667,-0.266667,0.461867,5.1696,-2.758933)"/></g></svg><span>Lichess</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:tearthdev@gmail.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>tearthdev@gmail.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Tearth.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme, hosted on <a href=https://pages.github.com/ rel="nofollow noopener" target=_blank>pages.github.com</a>.</span></div></div></footer></div></body></html>