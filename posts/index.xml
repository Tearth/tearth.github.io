<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Tearth's homepage</title><link>https://tearth.dev/posts/</link><description>Recent content in Posts on Tearth's homepage</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://tearth.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Inanis 1.4.0 released</title><link>https://tearth.dev/posts/inanis-1-4-0-released/</link><pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-4-0-released/</guid><description>&lt;p>A new update of the &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a> chess engine: check extensions, relative PST, countermove heuristic.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2950 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.4.0">https://github.com/Tearth/Inanis/releases/tag/v1.4.0&lt;/a>&lt;/p></description></item><item><title>Inanis 1.3.0 released</title><link>https://tearth.dev/posts/inanis-1-3-0-released/</link><pubDate>Fri, 14 Jun 2024 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-3-0-released/</guid><description>&lt;p>The next update of the &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a> chess engine: gradient descent tuner, improved SEE and evaluation.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2900 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.3.0">https://github.com/Tearth/Inanis/releases/tag/v1.3.0&lt;/a>&lt;/p></description></item><item><title>Performance of Bit Manipulation Instructions (BMI)</title><link>https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/</guid><description>&lt;p>&lt;strong>Bit Manipulation Instructions&lt;/strong> (BMI) is an interesting extension for the x86-64 architecture, introduced by Intel in Haswell processors (early 2010s). Its main purpose is, as the name suggests, increasing the speed of the most common bit operations by replacing manual calculation with dedicated instructions (which means hardware support). This article will focus on the performance of three example instructions: &lt;a href="https://www.felixcloutier.com/x86/BLSI">BLSI&lt;/a> (reads the lowest bit), &lt;a href="https://www.felixcloutier.com/x86/BLSR">BLSR&lt;/a> (resets the lowest bit) and &lt;a href="https://www.felixcloutier.com/x86/TZCNT">TZCNT&lt;/a> (counts the number of trailing non-set bits).&lt;/p></description></item><item><title>Inanis 1.2.0 released</title><link>https://tearth.dev/posts/inanis-1-2-0-released/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-2-0-released/</guid><description>&lt;p>Another major update of the &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a> chess engine: better Syzygy support, performance and stability improvement.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2850 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.2.0">https://github.com/Tearth/Inanis/releases/tag/v1.2.0&lt;/a>&lt;/p></description></item><item><title>Inanis 1.1.1 released</title><link>https://tearth.dev/posts/inanis-1-1-1-released/</link><pubDate>Sun, 14 Aug 2022 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-1-1-released/</guid><description>&lt;p>A small patch for the &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a> chess engine with improved compatibility with some GUIs.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2800 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.1.1">https://github.com/Tearth/Inanis/releases/tag/v1.1.1&lt;/a>&lt;/p></description></item><item><title>Inanis 1.1.0 released</title><link>https://tearth.dev/posts/inanis-1-1-0-released/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-1-0-released/</guid><description>&lt;p>Major update of the &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a> chess engine, introducing a lot of new features and improvements: Syzygy tablebases, MultiPV, adjusted evaluation and more. Full changelog below.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2800 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.1.0">https://github.com/Tearth/Inanis/releases/tag/v1.1.0&lt;/a>&lt;/p></description></item><item><title>Inanis 1.0.1 released</title><link>https://tearth.dev/posts/inanis-1-0-1-released/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-0-1-released/</guid><description>&lt;p>A small patch for the &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a>, addressing bugs found by the &lt;a href="http://talkchess.com/">TalkChess&lt;/a> community. The most important one fixes random crashes caused by the move legality check, giving false indications in rare cases. In the result, illegal moves were processed which led to the board state irreversibly corrupted.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2750 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.0.1">https://github.com/Tearth/Inanis/releases/tag/v1.0.1&lt;/a>&lt;/p></description></item><item><title>Inanis 1.0.0 released</title><link>https://tearth.dev/posts/inanis-1-0-0-released/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inanis-1-0-0-released/</guid><description>&lt;p>The first version of &lt;a href="https://github.com/Tearth/Inanis">Inanis&lt;/a>, a brand new chess engine written in Rust, is finally out! I&amp;rsquo;ve tried to make it as much feature-complete as possible, so it&amp;rsquo;s fully usable with any GUI supporting UCI protocol. If you find any bug, please &lt;a href="https://github.com/Tearth/Inanis/issues">make an issue&lt;/a> with possibly the most detailed description and steps to reproduce the problem, so I can investigate it.&lt;/p>
&lt;p>&lt;strong>Strength&lt;/strong>: 2750 Elo, &lt;strong>Link&lt;/strong>: &lt;a href="https://github.com/Tearth/Inanis/releases/tag/v1.0.0">https://github.com/Tearth/Inanis/releases/tag/v1.0.0&lt;/a>&lt;/p></description></item><item><title>Performance of chess engines written in C#, part 2</title><link>https://tearth.dev/posts/performance-of-chess-engines-written-in-csharp-part-2/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/performance-of-chess-engines-written-in-csharp-part-2/</guid><description>&lt;p>Half-year ago I did a small text about &lt;a href="https://tearth.dev/posts/performance-of-chess-engines-written-in-csharp-part-1/">writing chess engines in C# and performance issues related to it&lt;/a>, where I presented a few interesting methods of optimizing the engine. Today, I want to extend it a bit by new elements, some of them related to the lastly released .NET 5 - they aren&amp;rsquo;t game-changers, but can nicely improve some parts of code.&lt;/p></description></item><item><title>New bitboard viewer for chess engine developers</title><link>https://tearth.dev/posts/new-bitboard-viewer-for-chess-engine-developers/</link><pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/new-bitboard-viewer-for-chess-engine-developers/</guid><description>&lt;p>Just a quick announcement - I&amp;rsquo;ve made a new bitboard viewer, as a backup for the amazing &lt;a href="https://gekomad.github.io/Cinnamon/BitboardCalculator/">bitboard calculator made by gekomad&lt;/a> which supports my chess development since the beginning. I hope it will be helpful for some of you!&lt;/p>
&lt;p>&lt;strong>Link&lt;/strong>: &lt;a href="https://tearth.dev/bitboard-viewer/">https://tearth.dev/bitboard-viewer/&lt;/a> (with source code available &lt;a href="https://github.com/Tearth/Bitboard-Viewer">here&lt;/a>)&lt;/p></description></item><item><title>Inlining of intrinsic functions in .NET 5</title><link>https://tearth.dev/posts/inlining-of-intrinsic-functions-in-dot-net-5/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/inlining-of-intrinsic-functions-in-dot-net-5/</guid><description>&lt;p>For the last months, I was focused on developing &lt;a href="https://github.com/Tearth/Cosette">Cosette&lt;/a> chess engine, toying with a very wide spectrum of algorithms and language optimizations. The second one was especially interesting because of &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/dotnet-five">.NET 5 release&lt;/a>, which brings a few interesting speed improvements (I will try to write something about them in the context of the engine soon). In this article, I will show an interesting behavior of inlining intrinsic function in some specific case which led to the dropping of performance in the chess engine.&lt;/p></description></item><item><title>Performance of chess engines written in C#, part 1</title><link>https://tearth.dev/posts/performance-of-chess-engines-written-in-csharp-part-1/</link><pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/performance-of-chess-engines-written-in-csharp-part-1/</guid><description>&lt;p>Last month was quite busy - I&amp;rsquo;ve started a new project called Cosette, which is a brand new chess engine written in C# for .NET Core platform. It&amp;rsquo;s not my first project of this kind (a few years ago I made &lt;a href="https://github.com/Tearth/Proxima-b-2.0">Proxima b 2.0&lt;/a> (C#), together with even older &lt;a href="https://github.com/Tearth/Proxima-b">Proxima b&lt;/a> (C++)), so using the gained experience I can finally write a few words about performance tips and tricks, especially in C# language.&lt;/p></description></item><item><title>Performance of the different ways to swap two values</title><link>https://tearth.dev/posts/performance-of-the-different-ways-to-swap-two-values/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/performance-of-the-different-ways-to-swap-two-values/</guid><description>&lt;p>Swapping values is probably one of the simplest algorithms which can be imagined - we learn about it when starting our programming story. There are two popular ways to accomplish this: using a temporary variable and XORing (with some restrictions). In the newest C# versions there is also a third way, about which you can read in this article.&lt;/p></description></item><item><title>Mystery of Random class in .NET Framework and .NET Core</title><link>https://tearth.dev/posts/mystery-of-random-class-in-net-framework-and-net-core/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/mystery-of-random-class-in-net-framework-and-net-core/</guid><description>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.random.next?view=netcore-3.1">Random&lt;/a> class is one of the most used parts of the .NET library, which contains a few methods to generate pseudo-random numbers. They are extremely simple to use, but even with this, there are still some traps waiting for a programmer. In this article, I will focus on differences in implementation of this class between .NET Framework and .NET Core, especially seed generation which sometimes leads to interesting bugs.&lt;/p></description></item><item><title>Magic behind closures</title><link>https://tearth.dev/posts/magic-behind-closures/</link><pubDate>Thu, 02 Jul 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/magic-behind-closures/</guid><description>&lt;p>&lt;strong>Closure&lt;/strong> is a very important concept related to anonymous functions and lambdas. They allow a programmer to use local variables of the parent method inside a body of the inline function and then execute it at any time. The question is, how the C# compiler saves these local variables and how are they restored later - let&amp;rsquo;s check it.&lt;/p></description></item><item><title>GetHashCode inside CLR: Value types</title><link>https://tearth.dev/posts/gethashcode-inside-clr-value-types/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/gethashcode-inside-clr-value-types/</guid><description>&lt;p>In the &lt;a href="https://tearth.dev/posts/gethashcode-inside-clr-reference-types/">previous article&lt;/a>, we talked a bit about hash codes and how they are implemented for reference types - it turned out that it&amp;rsquo;s just a simple multiplication of thread ID and a random number. Today, we will do the same thing for value types, which are far more complex due to their representation in memory. In the end, I will show a small benchmark to prove that every struct defined by the programmer should override &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode&lt;/a> method. Time to dig into &lt;a href="https://github.com/dotnet/runtime">CLR source code&lt;/a>!&lt;/p></description></item><item><title>GetHashCode inside CLR: Reference types</title><link>https://tearth.dev/posts/gethashcode-inside-clr-reference-types/</link><pubDate>Mon, 08 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/gethashcode-inside-clr-reference-types/</guid><description>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode&lt;/a>, a part of the &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netcore-3.1">Object&lt;/a> class, is one of the key method present in every class instance. Its main purpose is to calculate and return a number associated with the specified object, which will be used as hash (a very good example is &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netcore-3.1">Dictionary&lt;/a> class). This article will be split into two parts: the first one will focus on the reference types and the second one on the value types. We will focus on the internal implementation of CLR and try to figure out how exactly the hash code for reference and value types is generated.&lt;/p></description></item></channel></rss>