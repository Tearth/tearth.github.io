<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Performance of Bit Manipulation Instructions (BMI) - Tearth's homepage</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content="Small discussion about Bit Manipulation Instructions (BMI) set, with a comparison of assembly code and performance between typical computations and intrinsic functions."><meta property="og:title" content="Performance of Bit Manipulation Instructions (BMI)"><meta property="og:description" content="Small discussion about Bit Manipulation Instructions (BMI) set, with a comparison of assembly code and performance between typical computations and intrinsic functions."><meta property="og:type" content="article"><meta property="og:url" content="https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/"><meta property="og:image" content="https://tearth.dev/img/card.jpg"><meta property="article:published_time" content="2020-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-06-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tearth.dev/img/card.jpg"><meta name=twitter:title content="Performance of Bit Manipulation Instructions (BMI)"><meta name=twitter:description content="Small discussion about Bit Manipulation Instructions (BMI) set, with a comparison of assembly code and performance between typical computations and intrinsic functions."><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/bundle.min.css><link rel="shortcut icon" href=/favicon.ico><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-167505664-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Tearth's homepage" rel=home><div class=logo__title>Tearth's homepage</div><div class=logo__tagline>Loosely updated site about everything I enjoy</div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Performance of Bit Manipulation Instructions (BMI)</h1><div class="post__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-06-01T00:00:00Z>2020-06-01</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/performance-comparisons/ rel=category>Performance comparisons</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#theory>Theory</a></li><li><a href=#tests>Tests</a><ul><li></li></ul></li><li><a href=#comparison>Comparison</a></li><li><a href=#a-few-words-about-c>A few words about C#</a></li><li><a href=#summary>Summary</a></li></ul></nav></div></div><div class="content post__content clearfix"><p><strong>Bit Manipulation Instructions</strong> (BMI) is an interesting extension for the x86-64 architecture, introduced by Intel in Haswell processors (early 2010s). Its main purpose is, as the name suggests, increasing the speed of the most common bit operations by replacing manual calculation with dedicated instructions (which means hardware support). This article will focus on the performance of three example instructions: <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a> (reads the lowest bit), <a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a> (resets the lowest bit) and <a href=https://www.felixcloutier.com/x86/TZCNT>TZCNT</a> (counts the number of trailing non-set bits).</p><h2 id=theory>Theory</h2><p>The first time I met with Bit Manipulation Instructions was during developing a chess engine <a href=https://github.com/Tearth/Proxima-b-2.0>Proxima b 2.0</a> for my thesis. It is important to know, that nearly every modern engine represents the chessboard in memory as <a href=https://www.chessprogramming.org/Bitboards>bitboards</a> - a collection of unsigned 64-bit variables, where every bit represents one field. Thanks to it, a lot of things (like generating moves or checking which pieces are currently attacked) can be done really fast using bit operations. The correct implementation is crucial for whole engine performance, and that&rsquo;s where hardware support for more complex expressions can be really useful. BMI isn&rsquo;t one solid pack of instructions - there are two main sets (which are identified separately by <a href=https://www.felixcloutier.com/x86/CPUID>CPUID</a> instruction):</p><ul><li><strong>BMI1</strong> contains 6 new instructions to resetting, extracting, counting and comparing</li></ul><table><thead><tr><th>Instruction name</th><th>Description</th></tr></thead><tbody><tr><td><a href=https://www.felixcloutier.com/x86/ANDN>ANDN</a></td><td>Performs logical AND with negated X and Y (<code>~x & y</code>)</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/BEXTR>BEXTR</a></td><td>Reads n bits starting from the specified index</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a></td><td>Reads the lowest bit (<code>x & ~x</code>)</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/BLSMSK>BLSMSK</a></td><td>Creates mask for all bits up to the lowest bit (<code>x ^ (x - 1)</code>)</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a></td><td>Resets the lowest bit (<code>x & (x - 1)</code>)</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/TZCNT>TZCNT</a></td><td>Calculates the number of trailing non-set bits</td></tr></tbody></table><ul><li><strong>BMI2</strong> contains 8 new instructions mainly for shifting, rotating and parallel operations</li></ul><table><thead><tr><th>Instruction name</th><th>Description</th></tr></thead><tbody><tr><td><a href=https://www.felixcloutier.com/x86/BZHI>BZHI</a></td><td>Zeros all bits from the specified index</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/MULX>MULX</a></td><td>Performs unsigned multiplication without affecting flags</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/PDEP>PDEP</a></td><td>Stores bits using the mask</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/PEXT>PEXT</a></td><td>Extracts bits using the mask</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/RORX>RORX</a></td><td>Rotates logical right without affecting flags</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/SARX:SHLX:SHRX>SARX</a></td><td>Performs arithmetic right shift without affecting flags</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/SARX:SHLX:SHRX>SHRX</a></td><td>Performs logical right shift without affecting flags</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/SARX:SHLX:SHRX>SHLC</a></td><td>Performs logical left shift without affecting flags</td></tr></tbody></table><p>What&rsquo;s more, AMD created its own sets:</p><ul><li><strong>ABM</strong> (Advanced Bit Manipulation) with two instructions: <a href=https://www.felixcloutier.com/x86/POPCNT>POPCNT</a> (calculates the number of set bits) and <a href=https://www.felixcloutier.com/x86/LZCNT>LZCNT</a> (calculates the number of leading non-set bits).</li><li><strong>TBM</strong> (Trailing Bit Manipulation) - a set of 10 instructions whose goal was to refill the original BMI set. You can read more about them in the <a href=https://www.amd.com/system/files/TechDocs/24594.pdf>AMD documentation</a>.</li></ul><p>As you can see, there are many ways to operate on bits using hardware support. In the next chapter, we will focus on performance of three instructions: <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a>, <a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a>, <a href=https://www.felixcloutier.com/x86/TZCNT>TZCNT</a>. First, we will write a program that performs operations using traditional mathematical formulas and then compares their performance with BMI instructions described above.</p><h2 id=tests>Tests</h2><p>Let&rsquo;s start with a generic template in C++, that will be used to perform tests. I&rsquo;ve decided to use <a href=https://en.cppreference.com/w/cpp/chrono>chrono library</a> which is amazing if you need accurate time measuring. There are also two lines from WinAPI (<a href=https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass>SetPriorityClass</a> and <a href=https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority>SetThreadPriority</a>) which set a priority of the process and thread to the highest possible (except realtime) - Linux users have to use <a href=https://linux.die.net/man/3/setpriority>setpriority</a> function. I think that the rest of the code is quite self-explaining, so let&rsquo;s go further.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;chrono&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;Windows.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=n>IterationsPerTest</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>SamplesCount</span> <span class=o>=</span> <span class=mi>4000000000</span><span class=p>;</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
    <span class=c1>// Set priorities
</span><span class=c1></span>    <span class=n>SetPriorityClass</span><span class=p>(</span><span class=n>GetCurrentProcess</span><span class=p>(),</span> <span class=n>HIGH_PRIORITY_CLASS</span><span class=p>);</span>
    <span class=n>SetThreadPriority</span><span class=p>(</span><span class=n>GetCurrentThread</span><span class=p>(),</span> <span class=n>THREAD_MODE_BACKGROUND_BEGIN</span><span class=p>);</span>

    <span class=c1>// Test
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>IterationsPerTest</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>auto</span> <span class=n>start</span> <span class=o>=</span> <span class=n>steady_clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>
        <span class=c1>// ...
</span><span class=c1></span>        <span class=c1>// Insert test function here
</span><span class=c1></span>        <span class=c1>// ...
</span><span class=c1></span>        <span class=k>auto</span> <span class=n>end</span> <span class=o>=</span> <span class=n>steady_clock</span><span class=o>::</span><span class=n>now</span><span class=p>();</span>

        <span class=k>auto</span> <span class=n>elapsed</span> <span class=o>=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>time</span> <span class=o>=</span> <span class=n>duration_cast</span><span class=o>&lt;</span><span class=n>milliseconds</span><span class=o>&gt;</span><span class=p>(</span><span class=n>elapsed</span><span class=p>).</span><span class=n>count</span><span class=p>();</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Iteration &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>time</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; ms&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Now, we will write a few functions and look at the assembly code generated by the compiler.</p><h4 id=blsi>BLSI</h4><p>At first, we will test <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a> instruction, which reads the lowest set bit and returns it. The equivalent formula for this operation is <code>x & -x</code> - ANDing variable with its negation, which works thanks to U2 (two&rsquo;s complement) system, where negating a number is just an inversion of all bits, and then adding 1. Let&rsquo;s see at the example for 8-bit number 108:</p><pre><code>    x = 01101100
   -x = 10010100

        01101100
    AND 10010100
    ------------
        00000100
</code></pre><p>Having this knowledge, let&rsquo;s see at the example implementation in C++. It&rsquo;s a simple for-loop which reads the lowest set bit from the iterator and then saves it to the variable. It&rsquo;s incredibly important to mark Result as volatile - without it, the compiler sees that all results except the last one will be overridden and it&rsquo;s high chance that it will optimize this to a single operation instead of a loop.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>Result</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>TestGetLsb</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SamplesCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>Result</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)((</span><span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>i</span> <span class=o>&amp;</span> <span class=o>-</span><span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>i</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Now let&rsquo;s check assembly code generated by the compiler for the loop. An optimization done here is a bit tricky, because there is not any negation performed here, what would be expected when we do <code>-(long long)i</code> operation. Instead of it, the compiler did it only once (for the initial value of <code>i</code>, so 0) before the loop and assigned a result to the <code>rdx</code> register. Every iteration, this register is decrementing which gives the same effect as for negating iterator and adding 1 every time. The rest of the assembly is quite straightforward - we can see <code>and</code> instruction with <code>rcx</code> (value of <code>rdx</code> just before decrementation) and <code>rax</code> (iterator) arguments. Then, the iterator is incremented and our result is saved to the variable. Last <code>cmp</code> and <code>jb</code> instructions just check if the loop should iterate more or not.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-nasm data-lang=nasm><span class=nf>mov</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rdx</span>
<span class=nf>dec</span> <span class=nb>rdx</span>
<span class=nf>and</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rax</span>
<span class=nf>inc</span> <span class=nb>rax</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=o>&lt;</span><span class=nv>unsigned</span> <span class=nv>__int64</span> <span class=nv>volatile</span> <span class=nv>Result</span><span class=o>&gt;</span><span class=p>],</span><span class=nb>rcx</span>
<span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span><span class=nb>rbp</span>
<span class=nf>jb</span> <span class=nv>cpptest.7FF64C3B1080</span></code></pre></td></tr></table></div></div><p>We know how does assembly code looks like for using formula directly, so let&rsquo;s check what we will see after using <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a> instruction. We have two ways to do it: first, we can change compiler properties to use AVX2 instruction set (Project -> Properties -> C/C++ -> Code Generation -> Enable Enhanced Instruction Set). Because this option includes also BMI sets, then it&rsquo;s a high chance that the compiler will detect a pattern and use specialized instruction directly (and results of my experiments confirm that it does indeed).</p><div class=post-image><a href=/img/1/instruction_set_properties.jpg><img src=/img/1/instruction_set_properties.jpg alt="Values available for Enable Enchanced Instruction Set option" decoding=async></a><div class=post-image-caption>Values available for Enable Enchanced Instruction Set option</div></div><p>The second option is to use <a href="https://docs.microsoft.com/en-us/cpp/intrinsics/x64-amd64-intrinsics-list?view=vs-2019">intrinsic functions</a>, which are the explicit way to tell the compiler that we want to use the specified instruction. For our experiments, we will use the second one. <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a> instruction is supported by <code>_blsi_u64</code> functions, which takes a number to process as the parameter, and returns the lowest set bit.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>TestGetLsb</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SamplesCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>Result</span> <span class=o>=</span> <span class=n>_blsi_u64</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Now the assembly code. As expected, a few instructions has been replaced by single <code>blsi</code> call with <code>rax</code> as the source, and <code>rcx</code> as destination register - so no more MOVing, ANDing and DECrementing. The rest of the code related to loop control remained the same.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-nasm data-lang=nasm><span class=nf>blsi</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rax</span>
<span class=nf>inc</span> <span class=nb>rax</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=o>&lt;</span><span class=nv>unsigned</span> <span class=nv>__int64</span> <span class=nv>volatile</span> <span class=nv>Result</span><span class=o>&gt;</span><span class=p>],</span><span class=nb>rcx</span>
<span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span><span class=nb>rbp</span>
<span class=nf>jb</span> <span class=nv>cpptest.7FF71FDD1080</span></code></pre></td></tr></table></div></div><p>One of the biggest concerns during performing a benchmark was overhead generated by the instructions related to loop (like controlling iterator or jumping). To minimize its effect, I did an additional test run called &ldquo;Zero&rdquo;, which contains the loop with the single assign of 0 to <code>Result</code> variable inside. Of course, it&rsquo;s far from ideal, but at least shows more or less the time needed by for-loop to do the most basic operation.</p><p>Tests were run for 4,000,000,000 samples in 10 independent iterations. As we can see at the table below, &ldquo;Zero&rdquo; pass takes about 1053 ms, so we can assume that it&rsquo;s the time necessary for loop and variable assignment. The intrinsic function has a very similar result, which differs by several dozen milliseconds. As expected, the longest run was during executing the &ldquo;Manual&rdquo; pass, where all calculations were performed using direct formula. Subtracting time got from &ldquo;Zero&rdquo; pass, we can assume that direct formula performs about 500 ms longer than intrinsic function.</p><table><thead><tr><th></th><th align=left>Zero [ms]</th><th align=left>Manual [ms]</th><th align=left>Intrinsic [ms]</th></tr></thead><tbody><tr><td>0</td><td align=left>1112</td><td align=left>1692</td><td align=left>1089</td></tr><tr><td>1</td><td align=left>1077</td><td align=left>1715</td><td align=left>1078</td></tr><tr><td>2</td><td align=left>1039</td><td align=left>1634</td><td align=left>1109</td></tr><tr><td>3</td><td align=left>1042</td><td align=left>1646</td><td align=left>1083</td></tr><tr><td>4</td><td align=left>1041</td><td align=left>1612</td><td align=left>1064</td></tr><tr><td>5</td><td align=left>1050</td><td align=left>1568</td><td align=left>1080</td></tr><tr><td>6</td><td align=left>1038</td><td align=left>1558</td><td align=left>1101</td></tr><tr><td>7</td><td align=left>1040</td><td align=left>1554</td><td align=left>1076</td></tr><tr><td>8</td><td align=left>1049</td><td align=left>1568</td><td align=left>1066</td></tr><tr><td>9</td><td align=left>1042</td><td align=left>1560</td><td align=left>1062</td></tr><tr><td><strong>Avg</strong></td><td align=left><strong>1053</strong></td><td align=left><strong>1611</strong></td><td align=left><strong>1081</strong></td></tr></tbody></table><h4 id=blsr>BLSR</h4><p><a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a> instruction resets the lowest set bit and returns the new value. Equivalent formula for this operations is <code>x & (x - 1)</code> - ANDing variable with its copy decreased by 1. Let&rsquo;s see at the example for 8-bit number 108 (similar as in previous chapter):</p><pre><code>    x = 01101100
x - 1 = 01101011

        01101100
    AND 01101011
    ------------
        01101000
</code></pre><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>Result</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>TestPopLsb</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SamplesCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>Result</span> <span class=o>=</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Assembly code generated by the compiler is pretty simple - <code>lea</code> instruction decrements <code>rax</code> register (where the iterator is stored), and stores result in the <code>rcx</code> register. Both <code>rax</code> and <code>rcx</code> are then ANDed and the result is stored to the <code>rcx</code> register. Next, <code>rax</code> (iterator) is incremented, the result of the <code>and</code> is stored to the <code>Result</code> variable and at the end, there is <code>cmp</code> and <code>jb</code> which are responsible for proper loop work.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-nasm data-lang=nasm><span class=nf>lea</span> <span class=nb>rcx</span><span class=p>,</span><span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=nb>rax</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
<span class=nf>and</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rax</span>
<span class=nf>inc</span> <span class=nb>rax</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=o>&lt;</span><span class=nv>unsigned</span> <span class=nv>__int64</span> <span class=nv>volatile</span> <span class=nv>Result</span><span class=o>&gt;</span><span class=p>],</span><span class=nb>rcx</span>
<span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span><span class=nb>rbp</span>
<span class=nf>jb</span> <span class=nv>cpptest.7FF6ABAF1076</span></code></pre></td></tr></table></div></div><p>The implementation using the intrinsic function is very familiar with the one from the previous chapter. Here we use <code>_blsr_u64</code> function, which does the same operation as in the previous code.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;immintrin.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>Result</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>TestPopLsb</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SamplesCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>Result</span> <span class=o>=</span> <span class=n>_blsr_u64</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>The assembly output for the intrinsic function is nearly the same as when using <code>_blsi_u64</code> - the only difference is the used instruction <code>blsr</code> instead of <code>blsi</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-nasm data-lang=nasm><span class=nf>blsr</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rax</span>
<span class=nf>inc</span> <span class=nb>rax</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=o>&lt;</span><span class=nv>unsigned</span> <span class=nv>__int64</span> <span class=nv>volatile</span> <span class=nv>Result</span><span class=o>&gt;</span><span class=p>],</span><span class=nb>rcx</span>
<span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span><span class=nb>rbp</span>
<span class=nf>jb</span> <span class=nv>cpptest.7FF79B791080</span></code></pre></td></tr></table></div></div><table><thead><tr><th></th><th align=left>Zero [ms]</th><th align=left>Manual [ms]</th><th align=left>Intrinsic [ms]</th></tr></thead><tbody><tr><td>0</td><td align=left>1083</td><td align=left>2314</td><td align=left>1101</td></tr><tr><td>1</td><td align=left>1045</td><td align=left>2216</td><td align=left>1073</td></tr><tr><td>2</td><td align=left>1056</td><td align=left>2178</td><td align=left>1075</td></tr><tr><td>3</td><td align=left>1058</td><td align=left>2098</td><td align=left>1071</td></tr><tr><td>4</td><td align=left>1061</td><td align=left>2093</td><td align=left>1073</td></tr><tr><td>5</td><td align=left>1060</td><td align=left>2097</td><td align=left>1081</td></tr><tr><td>6</td><td align=left>1057</td><td align=left>2088</td><td align=left>1085</td></tr><tr><td>7</td><td align=left>1069</td><td align=left>2092</td><td align=left>1074</td></tr><tr><td>8</td><td align=left>1041</td><td align=left>2084</td><td align=left>1063</td></tr><tr><td>9</td><td align=left>1052</td><td align=left>2091</td><td align=left>1068</td></tr><tr><td><strong>Avg</strong></td><td align=left><strong>1058</strong></td><td align=left><strong>2135</strong></td><td align=left><strong>1076</strong></td></tr></tbody></table><h4 id=tzcnt>TZCNT</h4><p>The last tested instruction, <a href=https://www.felixcloutier.com/x86/TZCNT>TZCNT</a>, counts trailing non-set bits. The algorithm is very simple: increment counter until the first bit in the source variable is not set, and shift it every iteration. If the first bit is set, or the counter is bigger than 64 (the size of type) then stop the whole loop.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>Result</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>TestTrailingZeros</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SamplesCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>x</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

        <span class=k>while</span> <span class=p>((</span><span class=n>x</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>count</span> <span class=o>&lt;</span> <span class=mi>64</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>x</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
            <span class=n>count</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>Result</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>count</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>The output assembly is a bit more complex, but the general idea is the same as for previous examples. You can say only by looking at this, that there are a lot of instructions, which will for sure consume processor time during computation.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-nasm data-lang=nasm><span class=nf>xor</span> <span class=nb>eax</span><span class=p>,</span><span class=nb>eax</span>
<span class=nf>mov</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rdx</span>
<span class=nf>test</span> <span class=nb>dl</span><span class=p>,</span><span class=mi>1</span>
<span class=nf>jne</span> <span class=nv>cpptest.7FF760DC108F</span>
<span class=nf>cmp</span> <span class=nb>eax</span><span class=p>,</span><span class=mi>40</span>
<span class=nf>jge</span> <span class=nv>cpptest.7FF760DC108F</span>
<span class=nf>shr</span> <span class=nb>rcx</span><span class=p>,</span><span class=mi>1</span>
<span class=nf>inc</span> <span class=nb>eax</span>
<span class=nf>test</span> <span class=nb>cl</span><span class=p>,</span><span class=mi>1</span>
<span class=nf>je</span> <span class=nv>cpptest.7FF760DC1080</span>
<span class=nf>inc</span> <span class=nb>rdx</span>
<span class=nf>movsxd</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>eax</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=o>&lt;</span><span class=nv>unsigned</span> <span class=nv>__int64</span> <span class=nv>volatile</span> <span class=nv>Result</span><span class=o>&gt;</span><span class=p>],</span><span class=nb>rcx</span>
<span class=nf>cmp</span> <span class=nb>rdx</span><span class=p>,</span><span class=nb>rbp</span>
<span class=nf>jb</span> <span class=nv>cpptest.7FF760DC1076</span></code></pre></td></tr></table></div></div><p>Now let&rsquo;s see at the intrinsic function. The equivalent of the manual counting zeros is <code>_tzcnt_u64</code>, which takes some number or variable, and then returns the number of trailing zeros.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;immintrin.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>Result</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>TestTrailingZeros</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>SamplesCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>Result</span> <span class=o>=</span> <span class=n>_tzcnt_u64</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>The output assembly code is without surprises - just <code>tzcnt</code> call with some instruction for a loop.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-nasm data-lang=nasm><span class=nf>tzcnt</span> <span class=nb>rcx</span><span class=p>,</span><span class=nb>rax</span>
<span class=nf>inc</span> <span class=nb>rax</span>
<span class=nf>mov</span> <span class=kt>qword</span> <span class=nv>ptr</span> <span class=nb>ds</span><span class=p>:[</span><span class=o>&lt;</span><span class=nv>unsigned</span> <span class=nv>__int64</span> <span class=nv>volatile</span> <span class=nv>Result</span><span class=o>&gt;</span><span class=p>],</span><span class=nb>rcx</span>
<span class=nf>cmp</span> <span class=nb>rax</span><span class=p>,</span><span class=nb>rbp</span>
<span class=nf>jb</span> <span class=nv>cpptest.7FF6AE1A1080</span></code></pre></td></tr></table></div></div><p>Tests indicate, that difference between manual computation and using the intrinsic function is really significant.</p><table><thead><tr><th></th><th align=left>Zero [ms]</th><th align=left>Manual [ms]</th><th align=left>Intrinsic [ms]</th></tr></thead><tbody><tr><td>0</td><td align=left>1068</td><td align=left>5020</td><td align=left>1133</td></tr><tr><td>1</td><td align=left>1042</td><td align=left>4868</td><td align=left>1090</td></tr><tr><td>2</td><td align=left>1056</td><td align=left>4674</td><td align=left>1076</td></tr><tr><td>3</td><td align=left>1044</td><td align=left>4676</td><td align=left>1048</td></tr><tr><td>4</td><td align=left>1064</td><td align=left>4660</td><td align=left>1093</td></tr><tr><td>5</td><td align=left>1056</td><td align=left>4665</td><td align=left>1143</td></tr><tr><td>6</td><td align=left>1049</td><td align=left>4660</td><td align=left>1059</td></tr><tr><td>7</td><td align=left>1040</td><td align=left>4673</td><td align=left>1052</td></tr><tr><td>8</td><td align=left>1084</td><td align=left>4655</td><td align=left>1045</td></tr><tr><td>9</td><td align=left>1077</td><td align=left>4655</td><td align=left>1051</td></tr><tr><td><strong>Avg</strong></td><td align=left><strong>1058</strong></td><td align=left><strong>4720</strong></td><td align=left><strong>1079</strong></td></tr></tbody></table><h2 id=comparison>Comparison</h2><p>Let&rsquo;s piece together our results. Values in columns &ldquo;Zero&rdquo;, &ldquo;Manual&rdquo; and &ldquo;Intrinsic&rdquo; are taken directly from the Avg row in all previous tables. Column &ldquo;Gain&rdquo; is calculated by the formula <code>((Manual - Zero) / (Intrinsic - Zero)) * 100%</code> which theoretically should give us information about how much better is the intrinsic function over manual calculating.</p><table><thead><tr><th></th><th align=left>Zero [ms]</th><th align=left>Manual [ms]</th><th align=left>Intrinsic [ms]</th><th align=left>Gain [%]</th></tr></thead><tbody><tr><td><a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a></td><td align=left>1053</td><td align=left>1611</td><td align=left>1081</td><td align=left>2006</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a></td><td align=left>1058</td><td align=left>2135</td><td align=left>1076</td><td align=left>5917</td></tr><tr><td><a href=https://www.felixcloutier.com/x86/TZCNT>TZCNT</a></td><td align=left>1058</td><td align=left>4721</td><td align=left>1079</td><td align=left>17441</td></tr></tbody></table><p>The final results are as follows: <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a> instruction is about 20 times faster than <code>i & (i - 1)</code>, <a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a> is about 60 times faster than <code>i & (i - 1)</code>, and <a href=https://www.felixcloutier.com/x86/TZCNT>TZCNT</a> is (with absolute record) about 175 times faster than manual computing based on the loop and shifting.</p><h2 id=a-few-words-about-c>A few words about C#</h2><p>Until recently, all responsibility for generating machine code was on the JIT (Just-in-time). It means you couldn&rsquo;t tell the compiler that you want to use some specific instruction, eg. <a href=https://www.felixcloutier.com/x86/BLSI>BLSI</a>. But according to the <a href=https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/>recent news</a>, .NET Core 3 adds an amazing feature which allows using intrinsic functions directly in the C# code. You can find them in the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86?view=netcore-3.1">System.Runtime.Intrinsics.X86</a> namespace - don&rsquo;t be suggested by the &ldquo;X86&rdquo; prefix, there are also versions for 64-bit functions but for some reason, they are inside X86 namespace.</p><p>Equivalents of functions in C# for intrinsic functions used in the previous chapters:</p><ul><li><strong>_blsi_u64</strong> - <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.bmi1.x64.extractlowestsetbit?view=netcore-3.1">System.Runtime.Intrinsics.X86.Bmi1.X64.ExtractLowestSetBit</a></li><li><strong>_blsr_u64</strong> - <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.bmi1.x64.resetlowestsetbit?view=netcore-3.1">System.Runtime.Intrinsics.X86.Bmi1.X64.ResetLowestSetBit</a></li><li><strong>_tzcnt_u64</strong> - <a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.bitoperations.trailingzerocount?view=netcore-3.1">System.Numerics.BitOperations.TrailingZeroCount</a></li></ul><h2 id=summary>Summary</h2><p>Today&rsquo;s compilers have very sophisticated mechanisms to optimize machine code - in 99% of cases, you will not use intrinsic functions directly by calling methods like <code>_blsr_u64</code> because the compiler will detect that programmer uses a formula to reset the lowest set bit and use <a href=https://www.felixcloutier.com/x86/BLSR>BLSR</a> instruction. After all, it&rsquo;s just good to know that things like this exist and are ready to improve the performance of the most critical parts of our applications - it&rsquo;s just a matter of enabling them in settings or use directly.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/.net/ rel=tag>.NET</a></li><li class=tags__item><a class="tags__link btn" href=/tags/.net-core/ rel=tag>.NET Core</a></li><li class=tags__item><a class="tags__link btn" href=/tags/c++/ rel=tag>C++</a></li><li class=tags__item><a class="tags__link btn" href=/tags/assembly/ rel=tag>Assembly</a></li><li class=tags__item><a class="tags__link btn" href=/tags/bmi/ rel=tag>BMI</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="Tearth avatar" src=https://github.com/Tearth.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About Tearth</span></div><div class=authorbox__description>C# programmer. After hours I enjoy writing chess engines, reading about history, space exploration and playing simulators or strategy games. I miss space shuttles.</div></div><nav class="pager flex"><div class="pager__item pager__item--next"><a class=pager__link href=/posts/gethashcode-inside-clr-reference-types/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>GetHashCode inside CLR: Reference types</p></a></div></nav><div id=comments><script>var id=2;var user_name="tearth";var repo_name="tearth.github.io";if(id)
{let url="https://github.com/"+user_name+"/"+repo_name+"/issues/"+id;let api_url="https://api.github.com/repos/"+user_name+"/"+repo_name+"/issues/"+id+"/comments";let link="<a href='"+url+"'>GitHub issue</a>";var commentsDiv=document.getElementById("comments");let xhr=new XMLHttpRequest();xhr.responseType="json";xhr.open("GET",api_url);xhr.setRequestHeader("Accept","application/vnd.github.v3.html+json");xhr.send();xhr.onload=function()
{if(xhr.status!=200)
{let errorText=document.createElement("p");errorText.innerHTML="<i>Comments for this post are not opened yet (or you have GitHub scripts disabled).</i>";commentsDiv.appendChild(errorText);}
else
{let comments=xhr.response;let mainHeader=document.createElement("h2");mainHeader.innerHTML="Comments: ".concat(comments.length);commentsDiv.appendChild(mainHeader);let issueLink=document.createElement("p");issueLink.innerHTML="<i>You can leave a comment using this <b>"+link+"</b>.</i>";commentsDiv.appendChild(issueLink);comments.forEach(function(comment)
{let commentContent=document.createElement("div");commentContent.setAttribute('class','gh-comment')
commentContent.innerHTML="".concat("<div class='gh-header'>","<img src='",comment.user.avatar_url,"' />","<div style='margin:auto 0;'>","<b><a class='gh-username' href='",comment.user.html_url,"'>",comment.user.login,"</a></b>"," commented at <em>",new Date(comment.created_at).toUTCString(),"</em>","</div>","</div>","<div class='gh-body'>",comment.body_html,"</div>");commentsDiv.appendChild(commentContent);});}};xhr.onerror=function()
{let errorText=document.createElement("p");errorText.innerHTML="<i>Looks like the GitHub API limit exceeded! Go to "+link+" directly or wait 60 minutes to reset limits.</i>";commentsDiv.appendChild(errorText);};}</script></div></div><aside class=sidebar><div class="widget-categories widget"><h4 class=widget__title>Bitboard viewer</h4><div class=widget__content><a href=https://tearth.dev/bitboard-viewer/ alt="Bitboard viewer">https://tearth.dev/bitboard-viewer/</a></div></div><div class="widget-categories widget"><h4 class=widget__title>Chess engines</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=https://github.com/Tearth/Inanis><span class=project-title>Inanis</span> - the strongest one, under development</a><div class=project-details><b>Elo: 2800</b>, Language: Rust, SLOC: 7000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/Cosette><span class=project-title>Cosette</span> - one of the best .NET engines</a><div class=project-details><b>Elo: 2500</b>, Language: C#, SLOC: 12000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/Proxima-b-2.0><span class=project-title>Proxima b 2.0</span> - made as part of BSc Thesis</a><div class=project-details><b>Elo: 1600</b>, Language: C#, SLOC: 10000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/Proxima-b><span class=project-title>Proxima b 1.0</span> - the weakest and simplest one</a><div class=project-details><b>Elo: 1000</b>, Language: C++, SLOC: 4000</div></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Other projects</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=https://github.com/skni-kod/MicrOS><span class=project-title>MicrOS</span> - 32-bit operating system</a><div class=project-details>Language: C, Assembly. SLOC: 40000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/InElonWeTrust><span class=project-title>InElonWeTrust</span> - SpaceX Discord bot</a><div class=project-details>Language: C#. SLOC: 6000</div></li><li class=widget__item><a class=widget__link href=https://github.com/Tearth/DotNet6502><span class=project-title>DotNet6502</span> - modular MOS 6502 emulator</a><div class=project-details>Language: C#. SLOC: 6000</div></li><li class=widget__item><a class=widget__link href="https://github.com/Tearth?tab=repositories">Full list of repositories</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Nuget packages</h4><div class=widget__content><ul class=widget__list><li class=widget__item><div><a class=widget__link href=https://github.com/Tearth/Oddity><span class=project-title>Oddity</span> - unofficial SpaceX API wrapper</a></div><div><a href=https://travis-ci.org/github/Tearth/Oddity><img src="https://img.shields.io/travis/Tearth/Oddity/master?style=flat-square&logo=travis-ci&logoColor=white&cacheSeconds=3600" alt="Oddity build"></a>
<a href=https://www.nuget.org/packages/Oddity/><img src="https://img.shields.io/nuget/dt/Oddity.svg?style=flat-square&logo=nuget&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt="Oddity Nuget"></a>
<a href=https://github.com/Tearth/Oddity/stargazers><img src="https://img.shields.io/github/stars/Tearth/Oddity.svg?style=flat-square&logo=github&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt="Oddity stargazers"></a></div><div class=project-details>Language: C#. SLOC: 3000</div></li><li class=widget__item><div><a class=widget__link href=https://github.com/Tearth/.NET-Launch-Dashboard><span class=project-title>.NET Launch Dashboard</span> - rocket telemetry</a></div><div><a href=https://travis-ci.org/github/Tearth/.NET-Launch-Dashboard><img src="https://img.shields.io/travis/Tearth/.NET-Launch-Dashboard/master?style=flat-square&logo=travis-ci&logoColor=white&cacheSeconds=3600" alt=".NET-Launch-Dashboard build"></a>
<a href=https://www.nuget.org/packages/DotNetLaunchDashboard/><img src="https://img.shields.io/nuget/dt/DotNetLaunchDashboard.svg?style=flat-square&logo=nuget&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt=".NET-Launch-Dashboard Nuget"></a>
<a href=https://github.com/Tearth/.NET-Launch-Dashboard/stargazers><img src="https://img.shields.io/github/stars/Tearth/.NET-Launch-Dashboard.svg?style=flat-square&logo=github&cacheSeconds=3600&color=rgb%2815%2c%20120%2c%20180%29" alt=".NET-Launch-Dashboard stargazers"></a></div><div class=project-details>Language: C#. SLOC: 500</div></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/.net-internals/>.NET internals (6)</a></li><li class=widget__item><a class=widget__link href=/categories/chess-engines/>Chess engines (5)</a></li><li class=widget__item><a class=widget__link href=/categories/performance-comparisons/>Performance comparisons (4)</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/.net/ title=.NET>.NET (9)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/.net-5/ title=".NET 5">.NET 5 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/.net-core/ title=".NET Core">.NET Core (8)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/.net-framework/ title=".NET Framework">.NET Framework (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/assembly/ title=Assembly>Assembly (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/bmi/ title=BMI>BMI (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/c++/ title=C++>C++ (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/chess/ title=Chess>Chess (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/clr/ title=CLR>CLR (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/gethashcode/ title=GetHashCode>GetHashCode (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/inanis/ title=Inanis>Inanis (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/random/ title=Random>Random (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/releases/ title=Releases>Releases (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/tuples/ title=Tuples>Tuples (1)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/Tearth target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Twitter rel="noopener noreferrer" href=https://twitter.com/TearthDev target=_blank><svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5.0-78.8 35.3-78.8 78.8.0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6.0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1.0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4.0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9.0 224.1-120 224.1-224.1.0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg><span>Twitter</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Lichess rel="noopener noreferrer" href=https://lichess.org/@/Tearth target=_blank><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="widget-social__link-icon icon icon-lichess" width="24" height="24" viewBox="2 3 21 21"><g id="surface1"><path style="fill-rule:evenodd;fill:#fff;fill-opacity:1;stroke-width:0" d="M22.001953 9.997559C32.497559 11.000977 38.503418 18.00293 37.998047 39.001465H15C15 30 24.997559 32.497559 22.998047 18.00293" transform="matrix(0.533333,0,0,0.533333,0,0)"/><path style="fill-rule:evenodd;fill:#fff;fill-opacity:1;stroke-width:0" d="M24.001465 18.00293C24.382324 20.910645 18.449707 25.371094 16.003418 26.99707 13.000488 28.996582 13.183594 31.340332 11.000977 31.003418 9.960938 30.058594 12.407227 27.956543 11.000977 28.000488 9.997559 28.000488 11.191406 29.230957 9.997559 30 9.001465 30 5.998535 31.003418 5.998535 26.000977 5.998535 24.001465 11.99707 13.996582 11.99707 13.996582S13.886719 12.099609 13.996582 10.50293C13.271484 9.506836 13.498535 8.503418 13.498535 7.5 14.501953 6.496582 16.501465 9.997559 16.501465 9.997559H18.500977S19.277344 8.005371 20.998535 7.001953L22.001953 9.997559" transform="matrix(0.533333,0,0,0.533333,0,0)"/><path style="fill-rule:evenodd;fill:#000;fill-opacity:1;stroke-width:0" d="M9.499512 25.50293C9.499512 25.773926 9.279785 26.000977 9.001465 26.000977 8.723145 26.000977 8.503418 25.773926 8.503418 25.50293 8.503418 25.224609 8.723145 24.997559 9.001465 24.997559 9.279785 24.997559 9.499512 25.224609 9.499512 25.50293zm0 0" transform="matrix(0.533333,0,0,0.533333,0,0)"/><path style="fill-rule:evenodd;fill:#000;fill-opacity:1;stroke-width:0" d="M14.999472 15.496922C14.996821 16.32729 14.774506 16.996929 14.499265 17.003609 14.226704 17.000284 13.999306 16.328111 14.001958 15.497742 13.998266 14.671036 14.22058 14.001397 14.499484 14.00106 14.778388 14.000723 14.995781 14.670215 14.999472 15.496922zm0 0" transform="matrix(0.461867,0.266667,-0.266667,0.461867,5.1696,-2.758933)"/></g></svg><span>Lichess</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:tearthdev@gmail.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>tearthdev@gmail.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2022 Tearth.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme, hosted on <a href=https://pages.github.com/ rel="nofollow noopener" target=_blank>pages.github.com</a>.</span></div></div></footer></div></body></html>