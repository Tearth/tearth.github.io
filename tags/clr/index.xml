<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CLR on Tearth's blog</title><link>https://tearth.dev/tags/clr/</link><description>Recent content in CLR on Tearth's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tearth.dev/tags/clr/index.xml" rel="self" type="application/rss+xml"/><item><title>GetHashCode inside CLR: Value types</title><link>https://tearth.dev/posts/gethashcode-inside-clr-value-types/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/gethashcode-inside-clr-value-types/</guid><description>&lt;p>In the &lt;a href="https://tearth.dev/posts/gethashcode-inside-clr-reference-types/">previous article&lt;/a>, we talked a bit about hash codes and how they are implemented for reference types - it turned out that it&amp;rsquo;s just a simple multiplication of thread ID and a random number. Today, we will do the same thing for value types, which are far more complex due to their representation in memory. In the end, I will show a small benchmark to prove that every struct defined by the programmer should override &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode&lt;/a> method. Time to dig into &lt;a href="https://github.com/dotnet/runtime">CLR source code&lt;/a>!&lt;/p></description></item><item><title>GetHashCode inside CLR: Reference types</title><link>https://tearth.dev/posts/gethashcode-inside-clr-reference-types/</link><pubDate>Mon, 08 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/gethashcode-inside-clr-reference-types/</guid><description>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode&lt;/a>, a part of the &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netcore-3.1">Object&lt;/a> class, is one of the key method present in every class instance. Its main purpose is to calculate and return a number associated with the specified object, which will be used as hash (a very good example is &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netcore-3.1">Dictionary&lt;/a> class). This article will be split into two parts: the first one will focus on the reference types and the second one on the value types. We will focus on the internal implementation of CLR and try to figure out how exactly the hash code for reference and value types is generated.&lt;/p></description></item></channel></rss>