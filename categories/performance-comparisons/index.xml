<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Performance comparisons on Tearth's blog</title><link>https://tearth.dev/categories/performance-comparisons/</link><description>Recent content in Performance comparisons on Tearth's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 09 Jul 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tearth.dev/categories/performance-comparisons/index.xml" rel="self" type="application/rss+xml"/><item><title>Mystery of Random class in .NET Framework and .NET Core</title><link>https://tearth.dev/posts/mystery-of-random-class-in-net-framework-and-net-core/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/mystery-of-random-class-in-net-framework-and-net-core/</guid><description>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.random.next?view=netcore-3.1">Random&lt;/a> class is one of the most used parts of the .NET library, which contains a few methods to generate pseudo-random numbers. They are extremely simple to use, but even with this, there are still some traps waiting for a programmer. In this article, I will focus on differences in implementation of this class between .NET Framework and .NET Core, especially seed generation which sometimes leads to interesting bugs.&lt;/p></description></item><item><title>GetHashCode inside CLR: Value types</title><link>https://tearth.dev/posts/gethashcode-inside-clr-value-types/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/gethashcode-inside-clr-value-types/</guid><description>&lt;p>In the &lt;a href="https://tearth.dev/posts/gethashcode-inside-clr-reference-types/">previous article&lt;/a>, we talked a bit about hash codes and how they are implemented for reference types - it turned out that it&amp;rsquo;s just a simple multiplication of thread ID and a random number. Today, we will do the same thing for value types, which are far more complex due to their representation in memory. In the end, I will show a small benchmark to prove that every struct defined by the programmer should override &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=netcore-3.1">GetHashCode&lt;/a> method. Time to dig into &lt;a href="https://github.com/dotnet/runtime">CLR source code&lt;/a>!&lt;/p></description></item><item><title>Performance of Bit Manipulation Instructions (BMI)</title><link>https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://tearth.dev/posts/performance-of-bit-manipulation-instructions-bmi/</guid><description>&lt;p>&lt;strong>Bit Manipulation Instructions&lt;/strong> (BMI) is an interesting extension for the x86-64 architecture, introduced by Intel in Haswell processors (early 2010s). Its main purpose is, as the name suggests, increasing the speed of the most common bit operations by replacing manual calculation with dedicated instructions (which means hardware support). This article will focus on the performance of three example instructions: &lt;a href="https://www.felixcloutier.com/x86/BLSI">BLSI&lt;/a> (reads the lowest bit), &lt;a href="https://www.felixcloutier.com/x86/BLSR">BLSR&lt;/a> (resets the lowest bit) and &lt;a href="https://www.felixcloutier.com/x86/TZCNT">TZCNT&lt;/a> (counts the number of trailing non-set bits).&lt;/p></description></item></channel></rss>